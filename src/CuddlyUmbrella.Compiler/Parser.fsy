%{

open CuddlyUmbrella.Compiler

let stringToTypeSpec = function
    | "void" -> Ast.Void
    | "int" -> Ast.Int
    | "float" -> Ast.Float
    | "bool" -> Ast.Bool
    | "string" -> Ast.String
    | _ -> failwith "Unknown type specificator string"

%}

// Keywords
%token DEF RETURN VAR IF THEN ELSE

%token <string>IDENT
%token <string>TYPE_SPEC

// Types
%token <System.Boolean>BOOL
%token <System.Int32>INT
%token <System.Single>FLOAT   
%token <System.String>STRING

// Punctuation
%token LPAREN RPAREN LBRACE RBRACE COLON SEMICOLON COMMA DBLQUOTE

// Operators
%token PLUS MINUS EQ LT GT LEQ GEQ

// Assignment arror
%token LARROW

// Misc tokens
%token EOF

%start program
%type <CuddlyUmbrella.Compiler.Ast.Program> program

%%

program:                
    | fun_decl_list stmt_list                              { ($1, $2) }

fun_decl_list:          
    | /* empty */                                          { [] }
    | fun_decl_list fun_decl                               { $1 @ [$2] }
    | fun_decl                                             { [$1] }

fun_decl:
    | DEF IDENT SEMICOLON                                  { Ast.FunctionDefinition $2 }

stmt_list:
    | /* empty */                                          { [] }
    | stmt_list stmt                                       { $1 @ [$2]}
    | stmt                                                 { [$1] }

stmt:
    | variable_decl                                        { $1 }

variable_decl:
    | VAR IDENT COLON TYPE_SPEC opt_expr SEMICOLON         { Ast.VariableDeclaration($2, (stringToTypeSpec $4), $5) }

opt_expr:
    | /* empty */                                          { None }
    | LARROW expr                                          { Some($2) }

expr: 
    | literal_expr                                         { Ast.LiteralExpression($1) }
    | IDENT                                                { Ast.IdentifierExpression($1) }
    | IDENT LPAREN arg_list RPAREN                         { Ast.FunctionCallExpression($1, $3) }

literal_expr:
    | BOOL                                                 { Ast.BoolLiteral($1) }
    | INT                                                  { Ast.IntLiteral($1) }
    | FLOAT                                                { Ast.FloatLiteral($1) }
    | STRING                                               { Ast.StringLiteral($1) }

arg_list:
    | /* empty */                                          { [] }
    | expr                                                 { [$1] }
    | arg_list COMMA expr                                  { $1 @ [$3] }
